#pragma once
#include <stdio.h>
#include "help.h"

/////////////////////////////////////////////////////////////////
//                                                             //
//                   Динамический массив                       //
//                                                             //
/////////////////////////////////////////////////////////////////

//-------------------//
// Структура массива //
//-------------------//
typedef struct Array_tag{

	int *p;   //Указатель
	int size; //Размер
	
} Array;

//----------------------------------------------------------------------------------------------------------------------//
// Функция создания нового массива() //
//----------------------------------------------------------------------------------------------------------------------//
Array createArray(){ 

	Array arr;
	arr.p = NULL;
	arr.size = 0;
	return arr;
	
};

//----------------------------------------------------------------------------------------------------------------------//
// Функция вывода массива в консоль([указатель на Array]) //
//----------------------------------------------------------------------------------------------------------------------//
int printArray(Array *arr){ 

	// если массив положительный, то выведем его
	if(arr->size > 0){

		for(int i = 0; i < arr->size; i++) printf("array[%d] = %d\n", i, arr->p[i]);

	}
 
	else printf("This is void array\n"); // в противном случае вернем ошибку

	return 0;
	
};

//----------------------------------------------------------------------------------------------------------------------//
// Функция вставки элемента массива ([указатель на Array], [номер элемента Array], [значение]) //
//----------------------------------------------------------------------------------------------------------------------//
int insertValueArray(Array *arr, int num, int value){ 

	// объявляем локальный указатель
	int *p;

	if(arr->size > 0) p = (int *)realloc(arr->p, (arr->size + 1) * sizeof(int)); // если массив уже положительный, то проводим реаллокацию
	else p = (int *)calloc(1, sizeof(int));                        			 	 // В противном случае проводим аллокацию с нуля
 
	if(p != NULL){   // если аллокация удалась, то совершаем действия
		arr->p = p;  													 	   // Передаем указатель в массив
		arr->size++; 													 	   // увеличиваем значение размера на 1
		for(int i = arr->size - 1; i > num; i--) arr->p[i] = arr->p[i - 1]; // Сдвигаем значения вправо
		arr->p[num] = value;
	}
	else return -1;  // в противном случае вернем ошибку

	return 0;
	
};

//----------------------------------------------------------------------------------------------------------------------//
// Функция добавления элемента в начало массива ([указатель на Array], [значение]) //
//----------------------------------------------------------------------------------------------------------------------//
int pushIntoBegin(Array *arr, int value){ 

	// объявляем локальный указатель
	int *p;

	if(arr->size > 0) p = (int *)realloc(arr->p, (arr->size + 1) * sizeof(int)); // если массив уже положительный, то проводим реаллокацию
	else p = (int *)calloc(1, sizeof(int));                        			 	 // В противном случае проводим аллокацию с нуля
 
	if(p != NULL){   // если аллокация удалась, то совершаем действия
		arr->p = p;  													 // Передаем указатель в массив
		arr->size++; 													 // увеличиваем значение размера на 1
		for(int i = arr->size - 1; i > 0; i--) arr->p[i] = arr->p[i - 1]; // Сдвигаем значения вправо
		arr->p[0] = value;
	}
	else return -1;  // в противном случае вернем ошибку

	return 0;
	
};

//----------------------------------------------------------------------------------------------------------------------//
// Функция добавления элемента в конец массива ([указатель на Array], [значение]) //
//----------------------------------------------------------------------------------------------------------------------//
int pushIntoEnd(Array *arr, int value){ 

	// объявляем локальный указатель
	int *p;

	if(arr->size > 0) p = realloc(arr->p, (arr->size + 1) * sizeof(int)); // если массив уже положительный, то проводим реаллокацию
	else p = malloc(sizeof(int));                        			      // В противном случае проводим аллокацию с нуля

	if(p != NULL){   // если аллокация удалась, то совершаем действия
		arr->p = p;  													 	   // Передаем указатель в массив
		arr->size++; 													 	   // увеличиваем значение размера на 1
		arr->p[arr->size - 1] = value;
	}
	else return -1;  // в противном случае вернем ошибку

	return 0;
	
};

//----------------------------------------------------------------------------------------------------------------------//
// Функция изменения размера массива ([указатель на Array], [размер, который мы хотим задать массиву]) //
//----------------------------------------------------------------------------------------------------------------------//
int setSizeArray(Array *arr, int size){ 

	// объявляем локальный указатель
	int *p;

	// если мы хотим задать положительную длину массива, то проводим аллокацию
	if(size > 0){

		if(arr->size > 0) p = (int *)realloc(arr->p, size * sizeof(int)); // если массив уже положительный, то проводим реаллокацию
		else p = (int *)calloc(size, sizeof(int));                        // В противном случае проводим аллокацию с нуля
 
		if(p != NULL){                        // если аллокация удалась, то передаем локальный указатель и размер структуре
			arr->p = p;
			arr->size = size;
		}
		else return -1;  // в противном случае вернем ошибку

	}

	// в противном случае высвобождаем память
	else free(arr->p);
	return 0;
	
};

//----------------------------------------------------------------------------------------------------------------------//
// Функция задания значения массива ([указатель на Array], [номер элемента Array], [значение]) //
//----------------------------------------------------------------------------------------------------------------------//
int setValueArray(Array *arr, int num, int value){ 

	// Если задан корректный номер, то присвоим значение элементу
	if(num < arr->size && num >= 0){
		
		arr->p[num] = value;
		return 0;
		
	}

	// в противном случае вернем ошибку
	else return -1;
	
};

//----------------------------------------------------------------------------------------------------------------------//
// Функция удаления элемента массива ([указатель на Array],[номер элемента Array]) //
//----------------------------------------------------------------------------------------------------------------------//
int deleteElementArray(Array *arr, int num){ 

	// Если задан корректный номер, то удалим элемент и сдвинем массив
	if(num < arr->size && num >= 0){
		
		for(int i = num; i < arr->size - 1; i++) arr->p[i] = arr->p[i + 1];
		arr->p = (int*)realloc(arr->p, (arr->size - 1)*sizeof(int));
		arr->size--;
		return 0;
		
	}

	// в противном случае вернем ошибку
	else return -1;
	
};

//-------------------------------------------------------------------------------------------//
// Функция перестановки двух элементов массива ([указатель на int],[указатель на int]) //
//-------------------------------------------------------------------------------------------//
int swap(int* a, int* b){
	int c = *a;
	*a = *b;
	*b = c;
};

//-------------------------------------------------------------------------//
// Функция выреза подмассива ([указатель на Array],[указатель на int],[указатель на int]) //
//-------------------------------------------------------------------------//
Array subArray(Array* arr, int first, int last){
	Array newArr;
	if(first < 0) first = 0;
	if(last >= arr->size) last = arr->size - 1;
	if(first < arr->size && last >= 0) for(int i = first; i <= last; i++) pushIntoEnd(&newArr, arr->p[i]);
};

//-------------------------------------------------------------------------//
// Функция объединения массивов ([указатель на Array],[указатель на Array]) //
//-------------------------------------------------------------------------//
int mergeArray(Array* arr1, Array* arr2){

	for(int i = 0; i < arr2->size; i++) pushIntoEnd(arr1, arr2->p[i]);
	return 0;

};
