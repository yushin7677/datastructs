#pragma once
#include "structs.h"
#include "help.h"
#include "tree.h"

//----------------------------------------------------------------------------------------------------------------------//
// Функция создания нового массива() //
//----------------------------------------------------------------------------------------------------------------------//
Array createArray(){ 

	Array arr;
	arr.p = NULL;
	arr.size = 0;
	return arr;
	
};

//----------------------------------------------------------------------------------------------------------------------//
// Функция вывода массива в консоль([указатель на Array]) //
//----------------------------------------------------------------------------------------------------------------------//
int printArray(Array *arr){ 

	// если массив положительный, то выведем его
	if(arr->size > 0){

		for(int i = 0; i < arr->size; i++) printf("array[%d] = %d\n", i, arr->p[i]);

	}
 
	else printf("This is void array\n"); // в противном случае вернем ошибку

	return 0;
	
};

//----------------------------------------------------------------------------------------------------------------------//
// Функция вставки элемента массива ([указатель на Array], [номер элемента Array], [значение]) //
//----------------------------------------------------------------------------------------------------------------------//
int insertValueArray(Array *arr, int num, int value){ 

	// объявляем локальный указатель
	int *p;

	if(arr->size > 0) p = (int *)realloc(arr->p, (arr->size + 1) * sizeof(int)); // если массив уже положительный, то проводим реаллокацию
	else p = (int *)calloc(1, sizeof(int));                        			 	 // В противном случае проводим аллокацию с нуля
 
	if(p != NULL){   // если аллокация удалась, то совершаем действия
		arr->p = p;  													 	   // Передаем указатель в массив
		arr->size++; 													 	   // увеличиваем значение размера на 1
		for(int i = arr->size - 1; i > num; i--) arr->p[i] = arr->p[i - 1]; // Сдвигаем значения вправо
		arr->p[num] = value;
	}
	else return -1;  // в противном случае вернем ошибку

	return 0;
	
};

//----------------------------------------------------------------------------------------------------------------------//
// Функция добавления элемента в начало массива ([указатель на Array], [значение]) //
//----------------------------------------------------------------------------------------------------------------------//
int pushIntoBegin(Array *arr, int value){ 

	// объявляем локальный указатель
	int *p;

	if(arr->size > 0) p = (int *)realloc(arr->p, (arr->size + 1) * sizeof(int)); // если массив уже положительный, то проводим реаллокацию
	else p = (int *)calloc(1, sizeof(int));                        			 	 // В противном случае проводим аллокацию с нуля
 
	if(p != NULL){   // если аллокация удалась, то совершаем действия
		arr->p = p;  													 // Передаем указатель в массив
		arr->size++; 													 // увеличиваем значение размера на 1
		for(int i = arr->size - 1; i > 0; i--) arr->p[i] = arr->p[i - 1]; // Сдвигаем значения вправо
		arr->p[0] = value;
	}
	else return -1;  // в противном случае вернем ошибку

	return 0;
	
};

//----------------------------------------------------------------------------------------------------------------------//
// Функция добавления элемента в конец массива ([указатель на Array], [значение]) //
//----------------------------------------------------------------------------------------------------------------------//
int pushIntoEnd(Array *arr, int value){ 

	// объявляем локальный указатель
	int *p;

	if(arr->size > 0) p = realloc(arr->p, (arr->size + 1) * sizeof(int)); // если массив уже положительный, то проводим реаллокацию
	else p = malloc(sizeof(int));                        			      // В противном случае проводим аллокацию с нуля

	if(p != NULL){   // если аллокация удалась, то совершаем действия
		arr->p = p;  													 	   // Передаем указатель в массив
		arr->size++; 													 	   // увеличиваем значение размера на 1
		arr->p[arr->size - 1] = value;
	}
	else return -1;  // в противном случае вернем ошибку

	return 0;
	
};

//----------------------------------------------------------------------------------------------------------------------//
// Функция изменения размера массива ([указатель на Array], [размер, который мы хотим задать массиву]) //
//----------------------------------------------------------------------------------------------------------------------//
int setSizeArray(Array *arr, int size){ 

	// объявляем локальный указатель
	int *p;

	// если мы хотим задать положительную длину массива, то проводим аллокацию
	if(size > 0){

		if(arr->size > 0) p = (int *)realloc(arr->p, size * sizeof(int)); // если массив уже положительный, то проводим реаллокацию
		else p = (int *)calloc(size, sizeof(int));                        // В противном случае проводим аллокацию с нуля
 
		if(p != NULL){                        // если аллокация удалась, то передаем локальный указатель и размер структуре
			arr->p = p;
			arr->size = size;
		}
		else return -1;  // в противном случае вернем ошибку

	}

	// в противном случае высвобождаем память
	else free(arr->p);
	return 0;
	
};

//----------------------------------------------------------------------------------------------------------------------//
// Функция задания значения массива ([указатель на Array], [номер элемента Array], [значение]) //
//----------------------------------------------------------------------------------------------------------------------//
int setValueArray(Array *arr, int num, int value){ 

	// Если задан корректный номер, то присвоим значение элементу
	if(num < arr->size && num >= 0){
		
		arr->p[num] = value;
		return 0;
		
	}

	// в противном случае вернем ошибку
	else return -1;
	
};

//----------------------------------------------------------------------------------------------------------------------//
// Функция удаления элемента массива ([указатель на Array],[номер элемента Array]) //
//----------------------------------------------------------------------------------------------------------------------//
int deleteElementArray(Array *arr, int num){ 

	// Если задан корректный номер, то удалим элемент и сдвинем массив
	if(num < arr->size && num >= 0){
		
		for(int i = num; i < arr->size - 1; i++) arr->p[i] = arr->p[i + 1];
		arr->p = (int*)realloc(arr->p, (arr->size - 1)*sizeof(int));
		arr->size--;
		return 0;
		
	}

	// в противном случае вернем ошибку
	else return -1;
	
};

//-------------------------------------------------------------------------------------------//
// Функция перестановки двух элементов массива ([указатель на int],[указатель на int]) //
//-------------------------------------------------------------------------------------------//
int swap(int* a, int* b){
	int c = *a;
	*a = *b;
	*b = c;
};

//-------------------------------------------------------------------------//
// Функция выреза подмассива ([указатель на Array],[указатель на int],[указатель на int]) //
//-------------------------------------------------------------------------//
Array subArray(Array* arr, int first, int last){
	Array newArr;
	if(first < 0) first = 0;
	if(last >= arr->size) last = arr->size - 1;
	if(first < arr->size && last >= 0) for(int i = first; i <= last; i++) pushIntoEnd(&newArr, arr->p[i]);
};

//-------------------------------------------------------------------------//
// Функция объединения массивов ([указатель на Array],[указатель на Array]) //
//-------------------------------------------------------------------------//
int mergeArray(Array* arr1, Array* arr2){

	for(int i = 0; i < arr2->size; i++) pushIntoEnd(arr1, arr2->p[i]);
	return 0;

};

/////////////////////////////////////////////////////////////////
//                                                             //
//            Сортировка динамического массива                 //
//                                                             //
/////////////////////////////////////////////////////////////////

//----------------------------------------------------------------------------------------------------------------------//
// Сортировка пузырьком ([указатель на Array]) //
//----------------------------------------------------------------------------------------------------------------------//
int bubbleSort(Array *arr){ 

	for(int i = 1; i < arr->size; i++)
		for(int j = 0; j < arr->size - i; j++)
			if(arr->p[j] > arr->p[j + 1]) swap(&(arr->p[j]), &(arr->p[j + 1]));

	return 0;
	
};

//----------------------------------------------------------------------------------------------------------------------//
// Сортировка расческой ([указатель на Array]) //
//----------------------------------------------------------------------------------------------------------------------//
int combSort(Array *arr){ 

	const double f = 1.247; // Магическое число для данной сортировки
	double r = arr->size/f;

	while(r >= 1){

		for(int j = 0; j + r < arr->size; j++){

			int i = j + r;
			if(arr->p[j] > arr->p[i]) swap(&(arr->p[j]), &(arr->p[i]));
			
		};

		r /= f;

	};

	return 0;
	
};

//-------------------------------------------//
// Быстрая сортировка ([указатель на Array]) //
//-------------------------------------------//
int quickSort(Array *arr){ 

	shortQuickSort(arr, 0, arr->size - 1);
	return 0;
	
};

//------------------------------------------------------------------//
// Быстрая сортировка подмассива ([указатель на Array],[int],[int]) //
//------------------------------------------------------------------//
int shortQuickSort(Array *arr, int first, int last){ 

	if(0 <= first && first <= last && last <= arr->size){
		int piv = arr->p[(first+ last)/2];
		int l = first;
		int r = last;
		while (l <= r){

		    while (arr->p[l] < piv) l++;
		    while (arr->p[r] > piv) r--;
		    if (l <= r){
				swap(&(arr->p[l]), &(arr->p[r]));
				l++;
				r--;
			};

		};
		if (first < r) shortQuickSort(arr, first, r);
	  	if (last > l) shortQuickSort(arr, l, last);
	};

	return 0;
	
};

//-------------------------------------------------------------------------------//
// Cлиянием 2 массивов с сортировкой([указатель на Array], [указатель на Array]) //
//-------------------------------------------------------------------------------//
Array sortedMerge(Array *arr1, Array *arr2){

	int i = 0, j = 0;
	Array arr3 = createArray();

	while(i < arr1->size && j < arr2->size){

		if(arr1->p[i] < arr2->p[j]){
			pushIntoEnd(&arr3, arr1->p[i]);
			i++;
		}
		else{
			pushIntoEnd(&arr3, arr2->p[j]);
			j++;
		};


	};

	while(i < arr1->size){
		pushIntoEnd(&arr3, arr1->p[i]);
		i++;
	};

	while(j < arr2->size){
		pushIntoEnd(&arr3, arr2->p[j]);
		j++;
	};

	return arr3;
};

//--------------------------------------------//
// Cортировка слиянием ([указатель на Array]) //
//--------------------------------------------//
int mergeSort(Array *arr){ 

	Array *arrays = malloc(arr->size * sizeof(Array));

	for(int i = 0; i < arr->size; i++){
		arrays[i] = createArray();
		pushIntoEnd(&(arrays[i]), arr->p[i]);
	};

	int howManyArrays = arr->size;

	while(howManyArrays > 1){

		int i = 0;

		while(i*2 < howManyArrays){
			if((i*2 + 1) < howManyArrays) arrays[i] = sortedMerge(&arrays[i*2], &arrays[i*2 + 1]);
			else arrays[i] = arrays[i*2];
			i++;
		};

		howManyArrays = i;

	};
	*arr = arrays[0];
	free(arrays);
	return 0;
	
};

//----------------------------------------------//
// Cортировка пирамидкой ([указатель на Array]) //
//----------------------------------------------//
int pyramidSort(Array *arr){ 

	BiTree biTree = createBiTree();
	if(arr->size > 0) biTree.root->value = arr->p[0];
	for(int i = 1; i < arr->size; i++) addValue(&biTree, arr->p[i]);
	free(arr->p);
	arr->size = 0;
	*arr = traversalBiTree(&biTree);
	return 0;
	
};
