#pragma once
#include <stdio.h>
#include "help.h"

/////////////////////////////////////////////////////////////////
//                                                             //
//                   Динамический массив                       //
//                                                             //
/////////////////////////////////////////////////////////////////

//-------------------//
// Структура массива //
//-------------------//
typedef struct Array_tag{

	int *p;   //Указатель
	int size; //Размер
	
} Array;

//-----------------------------------------------------//
// Функция создания нового массива(). Возвращает Array //
//-----------------------------------------------------//
Array createArray(void){ 

	Array arr;
	arr.p = NULL;
	arr.size = 0;
	return arr;
	
};

//----------------------------------------------------------------------------------------------------------------------//
// Функция вывода массива в консоль([указатель на Array]) //
//----------------------------------------------------------------------------------------------------------------------//
int printArray(Array *arr){ 

	// если массив положительный, то выведем его
	if(arr->size > 0){

		for(int i = 0; i < arr->size; i++) printf("array[%d] = %d\n", i, arr->p[i]);

	}
 
	else printf("This is void array\n"); // в противном случае вернем ошибку

	return 0;
	
};

//---------------------------------------------------------------------------------------------//
// Функция вставки элемента массива ([указатель на Array], [номер элемента Array], [значение]) //
//---------------------------------------------------------------------------------------------//
int insertToArray(Array *arr, int num, int value){ 

	// объявляем локальный указатель
	int *p;

	if(arr->size > 0) p = realloc(arr->p, (arr->size + 1) * sizeof(int)); // если массив уже положительный, то проводим реаллокацию
	else p = malloc(sizeof(int));                        			 	  // В противном случае проводим аллокацию с нуля
 
	arr->p = p;  													 	// Передаем указатель в массив
	arr->size++; 													 	// увеличиваем значение размера на 1
	for(int i = arr->size - 1; i > num; i--) arr->p[i] = arr->p[i - 1]; // Сдвигаем значения вправо
	arr->p[num] = value;

	return 1;
	
};

//----------------------------------------------------------------------------------------------------------------------//
// Функция добавления элемента в конец массива ([указатель на Array], [значение]) //
//----------------------------------------------------------------------------------------------------------------------//
int insertToEndArray(Array *arr, int value){ 

	// объявляем локальный указатель
	int *p;

	if(arr->size > 0) p = realloc(arr->p, (arr->size + 1) * sizeof(int)); // если массив уже положительный, то проводим реаллокацию
	else p = malloc(sizeof(int));                        			      // В противном случае проводим аллокацию с нуля

	arr->p = p;  													 	   // Передаем указатель в массив
	arr->size++; 													 	   // увеличиваем значение размера на 1
	arr->p[arr->size - 1] = value;

	return 0;
	
};

//----------------------------------------------------------------------------------------------------------------------//
// Функция изменения размера массива ([указатель на Array], [размер, который мы хотим задать массиву]) //
//----------------------------------------------------------------------------------------------------------------------//
int setSizeArray(Array *arr, int size){ 

	// если мы хотим задать положительную длину массива, то проводим аллокацию
	if(size > 0){

		if(arr->size > 0) arr->p = realloc(arr->p, size * sizeof(int)); // если массив уже положительный, то проводим реаллокацию
		else arr->p = malloc(size * sizeof(int));                       // В противном случае проводим аллокацию с нуля

		for(int i = arr->size; i < size; i++) arr->p[i] = 0;
		arr->size = size;

	}

	// в противном случае высвобождаем память
	else free(arr->p);
	return 1;
	
};

//----------------------------------------------------------------------------------------------------------------------//
// Функция задания значения массива ([указатель на Array], [номер элемента Array], [значение]) //
//----------------------------------------------------------------------------------------------------------------------//
int setValueArray(Array *arr, int num, int value){ 

	// Если задан корректный номер, то присвоим значение элементу
	if(num < arr->size && num >= 0){
		
		arr->p[num] = value;
		return 1;
		
	}

	// в противном случае вернем ошибку
	else return 0;
	
};

//----------------------------------------------------------------------------------------------------------------------//
// Функция удаления элемента массива ([указатель на Array],[номер элемента Array]) //
//----------------------------------------------------------------------------------------------------------------------//
int deleteElementArray(Array *arr, int num){ 

	// Если задан корректный номер, то удалим элемент и сдвинем массив
	if(num < arr->size && num >= 0){
		
		for(int i = num; i < arr->size - 1; i++) arr->p[i] = arr->p[i + 1];
		arr->p = (int*)realloc(arr->p, (arr->size - 1)*sizeof(int));
		arr->size--;
		return 1;
		
	}

	// в противном случае вернем ошибку
	else return 0;
	
};

//-------------------------------------------------------------------------//
// Функция выреза подмассива ([указатель на Array],[указатель на int],[указатель на int]) //
//-------------------------------------------------------------------------//
Array subArray(Array* arr, int first, int last){

	Array newArr = createArray();
	if(first < 0) first = 0;
	if(last >= arr->size) last = arr->size - 1;
	if(first < arr->size && last >= 0) for(int i = first; i <= last; i++) insertToEndArray(&newArr, arr->p[i]);
	return newArr;

};

//-------------------------------------------------------------------------//
// Функция объединения массивов ([указатель на Array],[указатель на Array]) //
//-------------------------------------------------------------------------//
int mergeArray(Array* arr1, Array* arr2){

	for(int i = 0; i < arr2->size; i++) insertToEndArray(arr1, arr2->p[i]);
	return 0;

};
