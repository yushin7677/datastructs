#pragma once
#include "list.h"

/////////////////////////////////////////////////////////////////
//                                                             //
//                          Очередь                            //
//                                                             //
/////////////////////////////////////////////////////////////////

typedef struct Queue_tag{

	Node *first, *last;

} Queue;

//----------------------------------------------------------------------------------------------------------------------//
// Функция создания очереди([указатель на Stack]) // возвращает 0
//----------------------------------------------------------------------------------------------------------------------//
Queue createQueue(){ 

	Queue queue;
	queue.first = NULL;
	queue.last = NULL;

	return queue;
	
};

//------------------------------------------------------//
// Функция вывода очереди в консоль([указатель на Stack]) //
//------------------------------------------------------//
int printQueue(Queue *queue){ 

	Node *node = queue->first;

	// если стек положительный, то выведем его
	if(queue->first != NULL){
		while(node != NULL){

			printf("value = %d\n", node->value);
			node = node->next;

		};
	}

	// в противном случае выведем сообщение о том, что очередь пуста
	else printf("printQueue: This is void queue\n");
	
};

//----------------------------------------------------------------------------------------------------------------------//
// Функция вставки элемента в очередь([указатель на Stack],[значение]) // возвращает 0 - успеха, -1 - ошибка
//----------------------------------------------------------------------------------------------------------------------//
int pushToQueue(Queue *queue, int value){ 

	// Создаем новый элемент
	Node *node = malloc(sizeof(Node));
	node->value = value;
	node->next = NULL;

	if(queue->first == NULL) queue->first = node; // Если новый элемент - первый в очереди, то обоначим его как первый и последний
	else queue->last->next = node;		          // Иначе последний элемент станет предпоследним
	queue->last = node; 						  // В любом случае новый элемент будет последним

	return 0;
	
};

//----------------------------------------------------------------------------------------------------------------------//
// Функция удаления элемента очереди ([указатель на Queue]) // возвращает значение удаленного элемента
//----------------------------------------------------------------------------------------------------------------------//
int popFromQueue(Queue *queue){

	// если в очередь не пустая
	if(queue->first != NULL){
		Node *node = queue->first;
		queue->first = queue->first->next;
		free(node);

		// Если очередь стала пустой, то и указатель на последний элемент должен опустеть
		if(queue->first == NULL) queue->last == NULL;
		return 1;
	}

	// в противном случае выведем сообщение о том, что стек пуст
	else return 0;
	
};
