#pragma once
#include <stdio.h>

/////////////////////////////////////////////////////////////////
//                                                             //
//                          Списки                             //
//                                                             //
/////////////////////////////////////////////////////////////////

//-----------------------------//
// Структура односвязного узла //
//-----------------------------//
typedef struct Node_tag{

	int value;
	struct Node_tag *next;
	
} Node;

//-------------------------------//
// Структура односвязного списка //
//-------------------------------//
typedef struct List_tag{

	Node *first;
	Node *last;
	
} List;

//-------------------------------------------------//
// Функция создания 1-списка ([указатель на List]) //
//-------------------------------------------------//
List createList(){ 

	List list;
	list.first = NULL;
	list.last = NULL;
	return list;
	
};

//------------------------------------------------------------//
// Функция вывода 1-списка ([указатель на List]) возвращает 0 //
//------------------------------------------------------------//
int printList(List *list){

	Node *node = list->first;

	// если стек положительный, то выведем его
	if(list->first != NULL){
		while(node != NULL){

			printf("value = %d\n", node->value);
			node = node->next;

		};
	}

	// в противном случае выведем сообщение о том, что стек пуст
	else printf("printStack: This is void stack\n");

	return 0;
	
};

//---------------------------------------------------------------------------------------------//
// Функция добавления узла в начало 1-списка ([указатель на List], [значение]) // возвращает 0 //
//---------------------------------------------------------------------------------------------//
int insertFirst(List *list, int value){ 

	Node *node = malloc(sizeof(Node));
	node->value = value;
	node->next = list->first;
	list->first = node;

	return 0;
	
};

//----------------------------------------------------------------------------------------------------------------------//
// Функция удаления узла из начала 1-списка ([указатель на List]) // возвращает 1 - успех, 0 - неудача
//----------------------------------------------------------------------------------------------------------------------//
int deleteFirst(List *list){ 

	// если стек положительный, то удалим первый элемент
	if(list->first != NULL){
		Node *node = list->first;
		list->first = list->first->next;
		free(node);
		return 1;
	}

	// в противном случае выведем сообщение о том, что стек пуст
	else return 0;
	
};

//----------------------------------------------------------------------------------------------------------------------//
// Функция добавления узла в конец 1-списка ([указатель на List], [значение]) // возвращает 0
//----------------------------------------------------------------------------------------------------------------------//
int insertLast(List *list, int value){ 

	// Создаем новый элемент
	Node *node = malloc(sizeof(Node));
	node->value = value;
	node->next = NULL;

	if(list->first == NULL) list->first = node; // Если новый элемент - первый в списке, то обоначим его как первый и последний
	else list->last->next = node;		        // Иначе последний элемент станет предпоследним
	list->last = node; 						    // В любом случае новый элемент будет последним

	return 0;
	
};

//----------------------------------------------------------------------------------------------------------------------//
// Функция удаления узла из конца 1-списка ([указатель на List]) // возвращает значение удаленного узла
//----------------------------------------------------------------------------------------------------------------------//
int deleteLast(List *list){ 

	// Если список не пустой:
	if(list->first != NULL){
		Node *node = list->first; // Создадим новый указатель на первый элемент

		// Если первый узел таккже является последним, то удалим его
		if(list->first == list->last){

			list->first = NULL;
			free(node);

		};

		// Иначе..
		else{
			while(node->next != list->last) node = node->next; // ищем предпослдний узел
			list->last = node;                                 // делаем его последним
			list->last->next = NULL;                           // ставим в его next NULL
			free(node->next);                                  // И освобождаем память
		};

		return 1;

	}

	// в противном случае выведем сообщение о том, что список пуст
	else printf("deleteFromEndList: This is void list\n");	
	return 0;
	
};
